
> права superuser позволяют получить доступ к структурам и функциям ядра

1 - fork без exec
0 - был fork был exec

States:
D - Device, - любое внешнее устройство - uninteraptable sleep (usually IO)
Прервать блокировку процесса при ожидании завершения IO нельзя
R - running or runnable (выполняется или в очереде готовых процессов) - система не различает выполняется он или в очереде находится
S - interruptable sleep - прерываемый сон, процесс ждет завершения события
Z - zombie - 

Zombie - отобраны все ресурсы кроме дескриптора. Он оставлен зомби чтобы parent смог получить статус завершения

Если бы не зомби, wait выполнялся бы бесконечно
В коде нет wait, тем не менее мы видим зомби

Вывод: система не анализирует, вызывается wait или нет
Если вызван wait, потомок завершится при вызове wait, когда парент завершится.

Система не контроллирует где есть exec, где wait. exec может быть даже в parent'е.
Любой потомок - потенциальный родитель. Exec переводит на адресное пространство.
Можно это сделать и в parent'е. Система этого не контроллирует.
Можно делать фигню. Это сделано для KISS.

0 - pid
0 - kthreadd - kernel thread daemon
2 - kworker - kernel worker - их столько, сколько ядер
  - ksoftirq - столько сколько ядер - отложенные действия - interrupt request 

## ls

Типы файлов:
- d - directory
--  - regular file
p   - program channel
l   - soft link

/dev - только тут
c   - character special file
b   - block special file

s   - sockets

SoftLink - спецтальный файл, содержащий символьную строку - путь к файлу
Так же его называют SymLink - SymbolicLink. Полное имя файла - путь к файлу и имя файла
Путь к файлу начинается со / - корневой каталог. Система разбирает / до очередного слеша.

Таким образом ищется файл. 
Система просматривает все составляющие имени до очередного слеша.

сколько типов файлов в юникс - 7

Что такое софтлинк - специальный файл содержит строку

В юниксе связные списки это структура struct list_head

struct list_head

struct task_struct


Используя именованный програмный канал, процесс который знает имя канала может записать
А процесс другой может прочитать (который знает имя канала)

Hard link - еще одно равноправное имя файла.
Файл можно удалить тогда и только тогда когда на него останется один хард линк.

# Про лабы

В 3 задаче во вторуюю включаем exec.
Запускаем программы с лабораторной.

В 4 программе нужен pipe. в паренте создаем один программный канал. child пишут в канал сообщения, парент читает.
Сообщения child сильно отличаются друг от друга.

В 5 программе, обработчик сигнала назвать signal_handler.
return ok - бан. return 0 - так нужно.
Дефайны для фигни использовать не нужно.

В обработчике сигнала нужно поменять флаг. Не надо называть mode. Mode - режим. Назови флаг. flag.

Во всех программах анализ wait не убираем. Как написали во второй анализ макросов, так должно и остаться.


